java锁：
    1.分类：
    (1)乐观锁：cas机制（比较并交换swap） 或者 加版本号  认为一个线程去拿数据的时候不会有其他线程对数据进行更改
        悲观所：认为一个线程去拿数据的时候一定会有其他线程对数据进行更改 synchronized
    (2)独享锁 共享锁 通过AQS（抽象队列同步器）实现
    独享锁：Reentrantlock（可重入锁） 一个线程独有   writelock是独享  synchronized
    共享锁：ReentrantReadWritelock readlock是共享锁
    AQS：如果被请求的共享资源空闲，则把当前请求共享资源的线程设置为有效线程，共享资源设置为锁定状态
    如果被请求的共享资源被占用，那么就需要一套线程阻塞以及唤醒时锁分配的机制，将获取不到锁的线程放入到阻塞队列中。由 volatile in state共享资源 + fifo等待队列组成
    (3)互斥锁 读写锁
    互斥锁：一个线程修改变量时加锁，其他线程等待   synchronized  reentrantlock
    读写锁：ReadWriteLock
    (4)可重入锁  reentrantlock synchronized
    同一个线程可以多次获取锁，state累加，获取多少次就需要释放多少次 state--
    (5)公平锁 非公平锁 https://www.zhihu.com/question/36964449
    公平锁：多个线程按照申请锁的顺序去获取锁，线程会直接进入队列去排队，永远是队列的第一位获取锁
    非公平锁：多个线程获取锁的时候，会直接尝试抢占，获取不到，会进入等待队列，如果能抢占到就直接获取锁
    公平锁和非公平锁，底层都是使用AQS来进行排队，线程被加入了等待队列之后，两者就没有区别
    区别在于新晋获取锁的线程，如果是非公平锁会有很多机会去抢占锁
    (6)分段锁
    ConcurrentHashMap 中的分段锁称为Segment，类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
    当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。



jvm：
    生命周期：加载、连接、初始化、使用、卸载
    类加载原理：1.将类的.class文件中的二进制读入到内存中
              2.然后将其放在运行时数据区的方法区中
              3.然后在堆中生成一个java.lang.Class对象，用来封装类在方法区内的数据结构

            类的加载机制包含加载、验证、准备、解析、初始化
            其中加载：将.class文件加载到对象中
            验证：确保加载的类符合JVM规范
            准备：正式为类变量分配内存并设置初始值
            解析：JVM常量池的符号引用转换为直接引用
            初始化：执行类的构造方法
            jvm的运行时数据区分为本地方法栈、程序计数器、元空间、堆、虚拟机栈、等

    https://www.sohu.com/a/254731966_465221
    https://zhuanlan.zhihu.com/p/99205555

    jvm内存：
        线程私有：
            程序计数器：指向虚拟机字节码指令的位置
            栈内存：栈内存和线程的生命周期相同
            本地方法栈：本地方法调用jni
        线程共享
            方法区：永久代 运行时常量池
            堆内存：存储对象或者数组 
                新生代 1/3（eden survivor0 s1 比例是8:1:1）     响应时间优先的应用，减少系统的响应时间；吞吐量优先的应用
                老年代 2/3
        直接内存：不受 jvm gc 管理


多线程：
    多线程的状态：新建 就绪 运行 阻塞 死亡
        新建：线程对象创建（）
        就绪：调用线程的start方法启动，等待cpu调度执行
        运行：线程执行中
        阻塞：执行到某个地方需要获取资源时，但是被其他人抢走锁定了，放弃了对cpu的使用权，等待锁释放继续执行
        死亡：执行完或者异常退出
    任务提交到线程，怎么执行：
        1.判断线程池的核心线程是否已满，不满开启核心线程工作
        2.判断工作队列是否已满，不满则加入到工作队列中 （4种工作队列）
        3.判断最大线程是否已满，不满新建线程执行，满了则执行饱和策略（4种饱和策略）




cephfs致力于文件系统接口，cephfs选择以目录树的形式内存管理和使用元数据信息
mds每次针对目录树的操作都是先写日志，再修改内存目录树结构，最后将修改的结果落盘
目录树的三个关键数据结构  inode dentry 和 dir
    inode: 存储具体文件和目录的元信息，inode是用来在metapool或datapool中查找对应的对象 （dir 或 文件）
    dentry：存储的是文件或目录的名字，用来连接inode和dir
    dir：通过items map记录自己管理的目录项dentry，且拥有一个和自己相连接的inode，通过inode可以继续向上回溯目录树

CephFS为什么需要部署MDS以及MDS的作用：
        1.1.启用CephFS接口需要在基础的Rados-Cluster存储集群之上需要额外运行一个MDS（Metadata-Server元数据服务器）的守护进程，由于Rados-Cluster本身就是一个对象存储服务，Rados-Cluster是没办法分开管理上面所说的传统文件系统中的数据和元数据的功能；
        1.2.因此MDS是专用于模拟传统文件系统所应该具有的将数据和元数据分离存储的方式而专门提供的一个守护进程服务。而且MDS只用来管理元数据；CephFS依赖于专用的MDS（MetaData-Server）组件管理元数据信息并向客户端输出一个倒置的树状层级结构： 
            1.将元数据先缓存于MDS的内存中然后再同步到Metadatapool,可以加快元数据的访问
            2.将cephfs的元数据的更新日志journal流式化后存储在RADOS集群上，journal日志是用来恢复mds里的元数据缓存。
            3.重启mds的时候会通过replay的方式从osd上加载之前缓存的元数据
            4.保存了文件系统的元数据(对象里保存了子目录和子文件的名称和inode编号)
        1.3.客户端(ceph.ko)-->MDS-->Rados-Cluster
            客户端要想使用ceph文件系统接口，内核级必须有对应的文件系统模块与之支持也就是ceph.ko模块，ceph.ko作为客户端每一次访问文件时必须基于套接字先连入到MDS来获取、返回文件的inode元数据信息，然后ceph.ko再到Rados-Cluster上以对象的方式把对象模拟成传统文件系统的"块"来加载文件的数据完成文件存取操作。



CephFS需要元数据存储池(metadatapool)和数据存储池(datapool)
        1.不管是RBD、CephFS、RadosGW，在Ceph（Rados-Cluster）上所有数据都应该先放在存储池pool中再映射到OSD上，而CephFS文件系统管理其数据和元数据时是分别放置在不同的存储池中进行的；
        2.Metadata Pool
            1.所有的元数据都是由MDS守护进程管理的，可以理解为：MDS作为客户端连入Rados-Cluster的CephFS的metadata-pool存储池存储元数据；
            2.而元数据是一类很密集的IO访问，需要占用的空间不大，但是对于性能的要求比较高，所以Metadata-Server会在本地使用内存当做高速缓存，所有操作都先在内存中完成，一段时间后再同步到MetadataPool当中实现元数据存储的.
        3.datapool
            数据直接写入datapool存储池
        4.需要注意的是：CephFS的Matadatapool一定只能被MDS访问（客户端是不能直接访问的），客户端对元数据的访问必须经由MDS来实现：
            当客户端打开一个数据时，它首先会向MDS请求此数据的inode,inode信息会告诉客户端此数据所有对象存放datapool中的位置和编号，然后客户端基于编号就可以加载到所有对象并访问到数据了。


大家好，我叫xxx，2017年毕业于山东师范大学
2016年11月份开始实习，正式工作于2017年到至今
其中2016年-2018年参与联通存量营销项目的开发
2018年开始接触云相关知识，为了解决公司云计算产品交付和实施遇到的一些问题，规范设计了k8s部署架构，开发了一套自动化部署集群的系统boots
2019-2020年基于k8s-dashboard、harbor等开源产品的了解和调研，集成相关产品开发的一套方便研发人员快速构建镜像，发布服务的私有云平台。
2020年至现在，负责仓储自动化运维平台的开发和问题处理。同时目前还在参与告警平台的开发。

